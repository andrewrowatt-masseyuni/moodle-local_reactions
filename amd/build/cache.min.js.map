{"version":3,"file":"cache.min.js","sources":["../src/cache.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * IndexedDB cache for emoji reactions data.\n *\n * Stores reaction counts locally so they can be rendered instantly on page load\n * before the web service response arrives. Only counts are cached (no user-specific\n * state). If IndexedDB is unavailable, all methods silently return null/void.\n *\n * @module     local_reactions/cache\n * @copyright  2026 Andrew Rowatt <A.J.Rowatt@massey.ac.nz>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/** @var {string} Database name. */\nconst DB_NAME = 'local_reactions_cache';\n\n/** @var {number} Database schema version. */\nconst DB_VERSION = 1;\n\n/** @var {string} Object store name. */\nconst STORE_NAME = 'reactions';\n\n/** @var {number} Cache TTL in milliseconds (1 week). */\nconst CACHE_TTL = 604800000;\n\n/** @var {IDBDatabase|null} Cached database connection. */\nlet db = null;\n\n/** @var {boolean} Whether we have already attempted to open the database. */\nlet dbAttempted = false;\n\n/**\n * Open (or return the cached) IndexedDB database connection.\n *\n * @returns {Promise<IDBDatabase|null>} The database, or null if unavailable.\n */\nconst getDb = () => {\n    if (db) {\n        return Promise.resolve(db);\n    }\n    if (dbAttempted) {\n        return Promise.resolve(null);\n    }\n    dbAttempted = true;\n\n    if (typeof indexedDB === 'undefined') {\n        return Promise.resolve(null);\n    }\n\n    return new Promise((resolve) => {\n        try {\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n            request.onupgradeneeded = (event) => {\n                const database = event.target.result;\n                if (!database.objectStoreNames.contains(STORE_NAME)) {\n                    database.createObjectStore(STORE_NAME, {keyPath: 'cacheKey'});\n                }\n            };\n\n            request.onsuccess = (event) => {\n                db = event.target.result;\n                resolve(db);\n            };\n\n            request.onerror = () => {\n                resolve(null);\n            };\n\n            request.onblocked = () => {\n                resolve(null);\n            };\n        } catch (e) {\n            resolve(null);\n        }\n    });\n};\n\n/**\n * Check whether IndexedDB caching is available.\n *\n * @returns {Promise<boolean>}\n */\nexport const isAvailable = async() => {\n    const database = await getDb();\n    return database !== null;\n};\n\n/**\n * Build a cache key for a post/item reaction.\n *\n * @param {string} component e.g. 'mod_forum'\n * @param {string} itemtype e.g. 'post'\n * @param {number} itemid The post ID.\n * @returns {string} Cache key.\n */\nexport const itemKey = (component, itemtype, itemid) => {\n    return `${component}:${itemtype}:item:${itemid}`;\n};\n\n/**\n * Build a cache key for a discussion-level reaction.\n *\n * @param {string} component e.g. 'mod_forum'\n * @param {string} itemtype e.g. 'post'\n * @param {number} discussionid The discussion ID.\n * @returns {string} Cache key.\n */\nexport const discussionKey = (component, itemtype, discussionid) => {\n    return `${component}:${itemtype}:discussion:${discussionid}`;\n};\n\n/**\n * Get a cached entry by key. Returns null if not found or expired.\n *\n * @param {string} key The cache key.\n * @returns {Promise<Object|null>} The cached data object, or null.\n */\nexport const get = async(key) => {\n    const database = await getDb();\n    if (!database) {\n        return null;\n    }\n\n    try {\n        return await new Promise((resolve) => {\n            const tx = database.transaction(STORE_NAME, 'readonly');\n            const store = tx.objectStore(STORE_NAME);\n            const request = store.get(key);\n\n            request.onsuccess = () => {\n                const record = request.result;\n                if (!record) {\n                    resolve(null);\n                    return;\n                }\n                // Check TTL.\n                if (Date.now() - record.timestamp > CACHE_TTL) {\n                    // Stale entry - delete it asynchronously and return null.\n                    try {\n                        const deleteTx = database.transaction(STORE_NAME, 'readwrite');\n                        deleteTx.objectStore(STORE_NAME).delete(key);\n                    } catch (e) {\n                        // Ignore deletion errors.\n                    }\n                    resolve(null);\n                    return;\n                }\n                resolve(record.data);\n            };\n\n            request.onerror = () => {\n                resolve(null);\n            };\n        });\n    } catch (e) {\n        return null;\n    }\n};\n\n/**\n * Get multiple cached entries by keys.\n *\n * @param {string[]} keys Array of cache keys.\n * @returns {Promise<Map<string, Object|null>>} Map of key to data (null if missing/expired).\n */\nexport const getMultiple = async(keys) => {\n    const results = new Map();\n    const database = await getDb();\n\n    if (!database || !keys.length) {\n        keys.forEach((key) => results.set(key, null));\n        return results;\n    }\n\n    try {\n        return await new Promise((resolve) => {\n            const tx = database.transaction(STORE_NAME, 'readonly');\n            const store = tx.objectStore(STORE_NAME);\n            const now = Date.now();\n            let pending = keys.length;\n\n            keys.forEach((key) => {\n                const request = store.get(key);\n\n                request.onsuccess = () => {\n                    const record = request.result;\n                    if (!record || (now - record.timestamp > CACHE_TTL)) {\n                        results.set(key, null);\n                    } else {\n                        results.set(key, record.data);\n                    }\n                    pending--;\n                    if (pending === 0) {\n                        resolve(results);\n                    }\n                };\n\n                request.onerror = () => {\n                    results.set(key, null);\n                    pending--;\n                    if (pending === 0) {\n                        resolve(results);\n                    }\n                };\n            });\n        });\n    } catch (e) {\n        keys.forEach((key) => {\n            if (!results.has(key)) {\n                results.set(key, null);\n            }\n        });\n        return results;\n    }\n};\n\n/**\n * Set a cache entry.\n *\n * @param {string} key The cache key.\n * @param {Object} data The reaction data to cache (counts only).\n * @returns {Promise<void>}\n */\nexport const set = async(key, data) => {\n    const database = await getDb();\n    if (!database) {\n        return;\n    }\n\n    try {\n        const tx = database.transaction(STORE_NAME, 'readwrite');\n        const store = tx.objectStore(STORE_NAME);\n        store.put({\n            cacheKey: key,\n            data: data,\n            timestamp: Date.now(),\n        });\n    } catch (e) {\n        // Silently fail.\n    }\n};\n\n/**\n * Set multiple cache entries in a single transaction.\n *\n * @param {Array<{key: string, data: Object}>} entries Array of entries to cache.\n * @returns {Promise<void>}\n */\nexport const setMultiple = async(entries) => {\n    const database = await getDb();\n    if (!database || !entries.length) {\n        return;\n    }\n\n    try {\n        const tx = database.transaction(STORE_NAME, 'readwrite');\n        const store = tx.objectStore(STORE_NAME);\n        const now = Date.now();\n\n        entries.forEach((entry) => {\n            store.put({\n                cacheKey: entry.key,\n                data: entry.data,\n                timestamp: now,\n            });\n        });\n    } catch (e) {\n        // Silently fail.\n    }\n};\n"],"names":["db","dbAttempted","getDb","Promise","resolve","indexedDB","request","open","onupgradeneeded","event","database","target","result","objectStoreNames","contains","createObjectStore","keyPath","onsuccess","onerror","onblocked","e","async","component","itemtype","itemid","discussionid","transaction","objectStore","get","key","record","Date","now","timestamp","delete","data","results","Map","keys","length","forEach","set","store","pending","has","tx","put","cacheKey","entries","entry"],"mappings":"mQAwCIA,GAAK,KAGLC,aAAc,QAOZC,MAAQ,IACNF,GACOG,QAAQC,QAAQJ,IAEvBC,YACOE,QAAQC,QAAQ,OAE3BH,aAAc,EAEW,oBAAdI,UACAF,QAAQC,QAAQ,MAGpB,IAAID,SAASC,oBAENE,QAAUD,UAAUE,KArCtB,wBAGG,GAoCPD,QAAQE,gBAAmBC,cACjBC,SAAWD,MAAME,OAAOC,OACzBF,SAASG,iBAAiBC,SAnC5B,cAoCCJ,SAASK,kBApCV,YAoCwC,CAACC,QAAS,cAIzDV,QAAQW,UAAaR,QACjBT,GAAKS,MAAME,OAAOC,OAClBR,QAAQJ,KAGZM,QAAQY,QAAU,KACdd,QAAQ,OAGZE,QAAQa,UAAY,KAChBf,QAAQ,OAEd,MAAOgB,GACLhB,QAAQ,gCAUOiB,SAEH,aADGnB,yBAYJ,CAACoB,UAAWC,SAAUC,mBAC/BF,sBAAaC,0BAAiBC,+BAWf,CAACF,UAAWC,SAAUE,yBACrCH,sBAAaC,gCAAuBE,2BAS/BJ,MAAAA,YACTX,eAAiBR,YAClBQ,gBACM,sBAIM,IAAIP,SAASC,gBAGhBE,QAFKI,SAASgB,YA1Gb,YA0GqC,YAC3BC,YA3GV,aA4GeC,IAAIC,KAE1BvB,QAAQW,UAAY,WACVa,OAASxB,QAAQM,UAClBkB,UAKDC,KAAKC,MAAQF,OAAOG,UAlHtB,YAqHuBvB,SAASgB,YAxH/B,YAwHuD,aACzCC,YAzHd,aAyHsCO,OAAOL,KAC1C,MAAOT,IAGThB,QAAQ,WAGZA,QAAQ0B,OAAOK,WAfX/B,QAAQ,OAkBhBE,QAAQY,QAAU,KACdd,QAAQ,UAGlB,MAAOgB,UACE,4BAUYC,MAAAA,aACjBe,QAAU,IAAIC,IACd3B,eAAiBR,YAElBQ,WAAa4B,KAAKC,cACnBD,KAAKE,SAASX,KAAQO,QAAQK,IAAIZ,IAAK,QAChCO,yBAIM,IAAIjC,SAASC,gBAEhBsC,MADKhC,SAASgB,YA7Jb,YA6JqC,YAC3BC,YA9JV,aA+JDK,IAAMD,KAAKC,UACbW,QAAUL,KAAKC,OAEnBD,KAAKE,SAASX,YACJvB,QAAUoC,MAAMd,IAAIC,KAE1BvB,QAAQW,UAAY,WACVa,OAASxB,QAAQM,QAClBkB,QAAWE,IAAMF,OAAOG,UApK/B,OAqKMG,QAAQK,IAAIZ,IAAK,MAEjBO,QAAQK,IAAIZ,IAAKC,OAAOK,MAE5BQ,UACgB,IAAZA,SACAvC,QAAQgC,UAIhB9B,QAAQY,QAAU,KACdkB,QAAQK,IAAIZ,IAAK,MACjBc,UACgB,IAAZA,SACAvC,QAAQgC,gBAK1B,MAAOhB,UACLkB,KAAKE,SAASX,MACLO,QAAQQ,IAAIf,MACbO,QAAQK,IAAIZ,IAAK,SAGlBO,uBAWIf,MAAMQ,IAAKM,cACpBzB,eAAiBR,WAClBQ,mBAKKmC,GAAKnC,SAASgB,YAnNT,YAmNiC,aAC9BmB,GAAGlB,YApNN,aAqNLmB,IAAI,CACNC,SAAUlB,IACVM,KAAMA,KACNF,UAAWF,KAAKC,QAEtB,MAAOZ,2BAWcC,MAAAA,gBACjBX,eAAiBR,WAClBQ,UAAasC,QAAQT,iBAMhBG,MADKhC,SAASgB,YA5OT,YA4OiC,aAC3BC,YA7ON,aA8OLK,IAAMD,KAAKC,MAEjBgB,QAAQR,SAASS,QACbP,MAAMI,IAAI,CACNC,SAAUE,MAAMpB,IAChBM,KAAMc,MAAMd,KACZF,UAAWD,SAGrB,MAAOZ"}