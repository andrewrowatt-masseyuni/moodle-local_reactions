{"version":3,"file":"utils.min.js","sources":["../src/utils.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Shared utilities for emoji reactions modules.\n *\n * @module     local_reactions/utils\n * @copyright  2026 Andrew Rowatt <A.J.Rowatt@massey.ac.nz>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport * as Cache from 'local_reactions/cache';\n\n/** @var {number} Duration in ms to keep animation classes before removal. */\nexport const ANIMATION_TIMEOUT = 2100;\n\n/**\n * Render a Mustache template and return the first element.\n *\n * @param {string} templateName The template name, e.g. 'local_reactions/reactions_bar'.\n * @param {Object} context The Mustache template context.\n * @returns {Promise<{element: HTMLElement, js: string}>}\n */\nexport const renderToElement = async(templateName, context) => {\n    const {html, js} = await Templates.renderForPromise(templateName, context);\n    const container = document.createElement('div');\n    container.innerHTML = html;\n    return {element: container.firstElementChild, js};\n};\n\n/**\n * Compare cached and fresh reaction data to find differences.\n *\n * @param {Object} cachedData Cached reaction data (counts only).\n * @param {Object} freshData Fresh reaction data from web service.\n * @returns {Object} Diffs object with hasChanges, changedEmojis, newEmojis, removedEmojis.\n */\nexport const computeDiffs = (cachedData, freshData) => {\n    const cachedCounts = {};\n    (cachedData?.counts || []).forEach((c) => {\n        cachedCounts[c.emoji] = c.count;\n    });\n\n    const freshCounts = {};\n    (freshData?.counts || []).forEach((c) => {\n        freshCounts[c.emoji] = c.count;\n    });\n\n    const changedEmojis = new Set();\n    const newEmojis = new Set();\n    const removedEmojis = new Set();\n\n    for (const emoji of Object.keys(freshCounts)) {\n        if (!(emoji in cachedCounts)) {\n            if (freshCounts[emoji] > 0) {\n                newEmojis.add(emoji);\n            }\n        } else if (freshCounts[emoji] !== cachedCounts[emoji]) {\n            changedEmojis.add(emoji);\n        }\n    }\n\n    for (const emoji of Object.keys(cachedCounts)) {\n        if (cachedCounts[emoji] > 0 && (!(emoji in freshCounts) || freshCounts[emoji] === 0)) {\n            removedEmojis.add(emoji);\n        }\n    }\n\n    const hasChanges = changedEmojis.size > 0 || newEmojis.size > 0 || removedEmojis.size > 0;\n\n    return {hasChanges, changedEmojis, newEmojis, removedEmojis};\n};\n\n/**\n * Build Mustache template context from reaction data.\n *\n * @param {Object} data Reaction data with counts array.\n * @param {Object} emojis Map of shortcode to unicode from config.\n * @param {Object} [options={}] Options.\n * @param {boolean} [options.canreact=false] Whether the user can react.\n * @param {boolean} [options.compactview=false] Whether to use compact view.\n * @param {string[]} [options.userreactions=[]] Emoji shortcodes the current user has reacted with.\n * @returns {Object} Template context.\n */\nexport const buildTemplateContext = (data, emojis, {canreact = false, compactview = false, userreactions = []} = {}) => {\n    const countsMap = {};\n    data.counts.forEach((c) => {\n        countsMap[c.emoji] = c.count;\n    });\n\n    const buttons = [];\n    let totalCount = 0;\n    const reactedEmojis = [];\n    let hasAnySelected = false;\n\n    for (const [shortcode, unicode] of Object.entries(emojis)) {\n        const count = countsMap[shortcode] || 0;\n        const isSelected = userreactions.includes(shortcode);\n        buttons.push({\n            shortcode: shortcode,\n            unicode: unicode,\n            count: count,\n            hascount: count > 0,\n            selected: isSelected,\n            canreact: canreact,\n        });\n        if (count > 0) {\n            totalCount += count;\n            reactedEmojis.push({unicode: unicode});\n            if (isSelected) {\n                hasAnySelected = true;\n            }\n        }\n    }\n\n    return {\n        buttons: buttons,\n        canreact: canreact,\n        compactview: compactview,\n        hasanycount: totalCount > 0,\n        totalcount: totalCount,\n        reactedEmojis: reactedEmojis,\n        selected: hasAnySelected,\n    };\n};\n\n/**\n * Create a poller that periodically calls a function and pauses when the tab is hidden.\n *\n * @param {number} intervalSeconds Polling interval in seconds. If <= 0, no polling is started.\n * @param {Function} pollFn The async function to call on each poll tick.\n */\nexport const createPoller = (intervalSeconds, pollFn) => {\n    if (!intervalSeconds || intervalSeconds <= 0) {\n        return;\n    }\n\n    let timer = setInterval(pollFn, intervalSeconds * 1000);\n\n    document.addEventListener('visibilitychange', () => {\n        if (document.hidden) {\n            if (timer) {\n                clearInterval(timer);\n                timer = null;\n            }\n        } else if (!timer) {\n            pollFn();\n            timer = setInterval(pollFn, intervalSeconds * 1000);\n        }\n    });\n};\n\n/**\n * Collect integer IDs from elements matching a selector.\n *\n * @param {string} selector CSS selector for the elements.\n * @param {string} attribute The attribute name containing the ID.\n * @returns {number[]} Array of parsed IDs.\n */\nexport const collectIds = (selector, attribute) => {\n    const ids = [];\n    document.querySelectorAll(selector).forEach((el) => {\n        const id = parseInt(el.getAttribute(attribute));\n        if (id) {\n            ids.push(id);\n        }\n    });\n    return ids;\n};\n\n/**\n * Apply animation classes to pills in a newly rendered bar based on diffs.\n *\n * @param {HTMLElement} newBar The new reactions bar element.\n * @param {Object} diffs The diff result from computeDiffs.\n * @param {boolean} compactview Whether compact view is enabled.\n */\nexport const applyDiffAnimations = (newBar, diffs, compactview) => {\n    if (!diffs.hasChanges) {\n        return;\n    }\n\n    if (!compactview) {\n        newBar.querySelectorAll('[data-emoji]').forEach((pill) => {\n            const emoji = pill.getAttribute('data-emoji');\n            if (diffs.changedEmojis.has(emoji)) {\n                pill.classList.add('local-reactions-count-changed');\n            }\n            if (diffs.newEmojis.has(emoji)) {\n                pill.classList.add('local-reactions-pill-new');\n            }\n        });\n    } else {\n        const compactPill = newBar.querySelector('.local-reactions-pill-compact');\n        if (compactPill) {\n            compactPill.classList.add('local-reactions-count-changed');\n        }\n    }\n};\n\n/**\n * Remove animation classes from a bar after the animation duration.\n *\n * @param {HTMLElement} bar The reactions bar element.\n */\nexport const clearAnimationClasses = (bar) => {\n    setTimeout(() => {\n        bar.querySelectorAll('.local-reactions-count-changed, .local-reactions-pill-new')\n            .forEach((el) => {\n                el.classList.remove('local-reactions-count-changed', 'local-reactions-pill-new');\n            });\n    }, ANIMATION_TIMEOUT);\n};\n\n/**\n * Update the IndexedDB cache for a batch of items.\n *\n * @param {number[]} ids The item/discussion IDs.\n * @param {Function} keyFn Function that takes an ID and returns a cache key.\n * @param {Object} dataMap Map of ID to reaction data (must have a counts property).\n * @returns {Promise<void>}\n */\nexport const updateCacheBatch = async(ids, keyFn, dataMap) => {\n    const cacheAvailable = await Cache.isAvailable();\n    if (!cacheAvailable) {\n        return;\n    }\n\n    const entries = [];\n    for (const id of ids) {\n        const data = dataMap[id];\n        if (data) {\n            entries.push({\n                key: keyFn(id),\n                data: {counts: data.counts || []},\n            });\n        }\n    }\n\n    if (entries.length > 0) {\n        await Cache.setMultiple(entries);\n    }\n};\n"],"names":["async","templateName","context","html","js","Templates","renderForPromise","container","document","createElement","innerHTML","element","firstElementChild","cachedData","freshData","cachedCounts","counts","forEach","c","emoji","count","freshCounts","changedEmojis","Set","newEmojis","removedEmojis","Object","keys","add","hasChanges","size","data","emojis","canreact","compactview","userreactions","countsMap","buttons","totalCount","reactedEmojis","hasAnySelected","shortcode","unicode","entries","isSelected","includes","push","hascount","selected","hasanycount","totalcount","intervalSeconds","pollFn","timer","setInterval","addEventListener","hidden","clearInterval","selector","attribute","ids","querySelectorAll","el","id","parseInt","getAttribute","newBar","diffs","compactPill","querySelector","classList","pill","has","bar","setTimeout","remove","keyFn","dataMap","Cache","isAvailable","key","length","setMultiple"],"mappings":"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"}